// Generated by CoffeeScript 2.5.1
(function() {
  // tupelo-main.coffee
  // vim: sts=2 sw=2 et:
  var $,
    hasProp = {}.hasOwnProperty;

  $ = jQuery;

  $(document).ready(function() {
    var ajaxErr, cardClicked, cardPlayed, clearTable, dbg, escapeHtml, eventsOk, gameCreateOk, gameInfoOk, getGameState, getTeamPlayers, hello, leaveOk, leftGame, listGamesOk, listPlayersOk, messageReceived, processEvent, quitOk, registerOk, request, setState, startOk, stateChanged, states, trickPlayed, tupelo, turnEvent, updateGameLinks, updateGameState, updateHand, updateLists;
    // status object
    tupelo = {
      game_state: {},
      events: [],
      config: {
        serverBaseUrl: "/api"
      }
    };
    states = {
      initial: {
        show: ["#register_form"],
        hide: ["#quit_form", "#games", "#players", "#my_game", "#game"],
        change: function() {
          var reg;
          reg = $("#register_name");
          reg.addClass("initial");
          reg.val("Your name");
        }
      },
      registered: {
        show: ["#quit_form", "#games", "#players", "#game_create_form"],
        hide: ["#register_form", "#my_game", "#game"],
        change: function() {
          if (tupelo.list_timer == null) {
            return tupelo.list_timer = setInterval(updateLists, 5000);
          }
        }
      },
      gameCreated: {
        show: ["#my_game"],
        hide: ["#game_create_form"]
      },
      inGame: {
        show: ["#game"],
        hide: ["#games", "#players", "#my_game"]
      }
    };
    // change the current state
    setState = function(state, effectDuration) {
      var elem, j, k, len, len1, ref, ref1, st;
      st = states[state];
      ref = st.hide;
      for (j = 0, len = ref.length; j < len; j++) {
        elem = ref[j];
        $(elem).hide(effectDuration);
      }
      ref1 = st.show;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        elem = ref1[k];
        $(elem).show(effectDuration);
      }
      if (st.change != null) {
        return st.change();
      }
    };
    escapeHtml = function(str) {
      return str.replace("<", "&lt;").replace(">", "&gt;");
    };
    dbg = function() {
      if (T.debug) {
        return $("#debug").html(JSON.stringify(tupelo));
      }
    };
    // generic ajax error callback
    ajaxErr = function(xhr, astatus, error) {
      var handled, jsonErr;
      handled = false;
      // 403 is for game and rule errors
      if (xhr.status === 403) {
        // parse from json
        jsonErr = eval("(" + xhr.responseText + ")");
        if (jsonErr.message != null) {
          window.alert(jsonErr.message);
          handled = true;
        }
      } else {
        T.log("status: " + astatus);
        T.log("error: " + error);
      }
      return handled;
    };
    request = function(opts) {
      opts.url = tupelo.config.serverBaseUrl + opts.url;
      opts.error = opts.error || ajaxErr;
      return $.ajax(opts);
    };
    hello = function() {
      return request({
        url: "/hello",
        success: function(result) {
          T.log("Server version: " + result.version);
          // are we already logged in?
          if (result.player != null) {
            tupelo.player = new T.Player(result.player.player_name);
            registerOk(result.player);
            // are we in a game?
            if (result.player.game_id != null) {
              return gameCreateOk(result.player.game_id);
            }
          }
        }
      });
    };
    updateGameLinks = function(disabledIds) {
      var gameJoinClicked, id, j, len;
      gameJoinClicked = function(event) {
        var game_id;
        // "game_join_ID"
        game_id = this.id.slice(10);
        T.log("joining game " + game_id);
        return request({
          url: "/game/enter",
          data: {
            akey: tupelo.player.akey,
            game_id: game_id
          },
          success: gameCreateOk
        });
      };
      if (tupelo.game_id != null) {
        $("button.game_join").attr("disabled", true);
        return $("tr#game_id_" + tupelo.game_id).addClass("highlight");
      } else {
        for (j = 0, len = disabledIds.length; j < len; j++) {
          id = disabledIds[j];
          $("button#" + id).attr("disabled", true);
        }
        return $("button.game_join").click(gameJoinClicked);
      }
    };
    listGamesOk = function(result) {
      var disabledIds, game, html, j, len, players, res;
      //T.log "listGamesOk"
      //T.log result
      html = "";
      disabledIds = [];
      for (j = 0, len = result.length; j < len; j++) {
        game = result[j];
        html += `<tr id=\"game_id_${game.id}\">`;
        //players = []
        //for res in result[game_id]
        //  plr = new T.Player().fromObj res
        //  players.push plr.player_name
        players = (function() {
          var k, len1, ref, results;
          ref = game.players;
          results = [];
          for (k = 0, len1 = ref.length; k < len1; k++) {
            res = ref[k];
            results.push(new T.Player().fromObj(res).player_name);
          }
          return results;
        })();
        html += "<td>" + escapeHtml(players.join(", ")) + "</td>";
        html += "<td class=\"game_list_actions\"><button class=\"game_join btn\" id=\"game_join_" + game.id + "\"><span><span>join</span></span></button></td>";
        html += "</tr>";
        if (players.length === 4) {
          disabledIds.push(`game_join_${game.id}`);
        }
      }
      $("#game_list table tbody").html(html);
      updateGameLinks(disabledIds);
      return dbg();
    };
    listPlayersOk = function(result) {
      var cls, html, player, plr;
      T.log(result);
      html = "";
      for (player in result) {
        if (!hasProp.call(result, player)) continue;
        plr = new T.Player().fromObj(result[player]);
        if (plr.id !== tupelo.player.id) {
          cls = plr.game_id != null ? "class=\"in_game\" " : "";
          html += `<tr ${cls}id=\"player_id_` + plr.id + "\">";
          html += "<td>" + escapeHtml(plr.player_name) + "</td></tr>";
        }
      }
      $("#player_list table tbody").html(html);
      return dbg();
    };
    registerOk = function(result) {
      $("#name").val("");
      tupelo.player.id = result.id;
      tupelo.player.akey = result.akey;
      Cookies.set("akey", result.akey);
      T.log(tupelo);
      dbg();
      // clear game list if there was one previously
      $("#game_list table tbody").html("");
      $(".my_name").html(escapeHtml(tupelo.player.player_name));
      updateLists();
      setState("registered", "fast");
      return T.log("timer created");
    };
    leftGame = function() {
      if (tupelo.event_fetch_timer != null) {
        tupelo.event_fetch_timer.disable();
        tupelo.event_fetch_timer = null;
      }
      if (tupelo.event_timer != null) {
        clearTimeout(tupelo.event_timer);
        tupelo.event_timer = null;
      }
      tupelo.game_id = null;
      tupelo.game_state = {};
      tupelo.hand = null;
      tupelo.my_turn = null;
    };
    leaveOk = function(result) {
      leftGame();
      dbg();
      updateLists();
      return setState("registered", "fast");
    };
    quitOk = function(result) {
      leftGame();
      if (tupelo.list_timer != null) {
        clearInterval(tupelo.list_timer);
        tupelo.list_timer = null;
      }
      Cookies.remove("akey");
      tupelo.player = null;
      T.log(tupelo);
      dbg();
      return setState("initial", "fast");
    };
    gameCreateOk = function(result) {
      tupelo.game_id = result;
      T.log(tupelo);
      dbg();
      $("p#joined_game").html(`joined game ${tupelo.game_id}`);
      setState("gameCreated", "fast");
      tupelo.event_fetch_timer = new T.Timer(tupelo.config.serverBaseUrl + "/get_events", 2000, eventsOk, {
        data: {
          akey: tupelo.player.akey
        }
      });
      return updateLists();
    };
    cardPlayed = function(event) {
      var card, table;
      T.log("cardPlayed");
      //T.log event
      table = $("#player_" + event.player.id + " .table");
      if (table.length === 0) {
        T.log("player not found!");
        return true;
      }
      //table.hide()
      card = new T.Card(event.card.suit, event.card.value);
      table.html("<span style=\"display: none;\" class=\"card\">" + card.toShortHtml() + "</span>");
      table.children().show(500);
      setTimeout(processEvent, 500);
      return false;
    };
    messageReceived = function(event) {
      var eventLog;
      T.log("messageReceived");
      eventLog = $("#event_log");
      eventLog.append(escapeHtml(event.sender) + ": " + escapeHtml(event.message) + "\n");
      eventLog.scrollTop(eventLog[0].scrollHeight - eventLog.height());
      return true;
    };
    // clear the table and resume event processing
    // called either from timeout or click event
    clearTable = function() {
      clearTimeout(tupelo.clear_timeout);
      T.log("clearing table");
      $("#game_area .table").html("");
      $("#game_area table tbody").unbind("click");
      // re-enable event processing
      return tupelo.event_timer = setTimeout(processEvent, 0);
    };
    //T.log("trickPlayed: set event_timer to " + tupelo.event_timer)
    trickPlayed = function(event) {
      T.log("trickPlayed");
      // TODO: highlight the highest card
      // allow the user to clear the table and proceed by clicking the table
      $("#game_area table tbody").click(clearTable);
      // setting timeout to show the played trick for a longer time
      tupelo.clear_timeout = setTimeout(clearTable, 5000);
      return false; // this event is not handled yet
    };
    getTeamPlayers = function(team) {
      // TODO: should we store these in JS instead of the DOM?
      return [$("#table_" + team + " .player_name").html(), $("#table_" + (team + 2) + " .player_name").html()];
    };
    updateGameState = function(state) {
      var key, statusStr;
      statusStr = "";
      for (key in state) {
        if (!hasProp.call(state, key)) continue;
        tupelo.game_state[key] = state[key];
      }
      // show game status (voting, nolo, rami)
      if (state.status === T.VOTING) {
        statusStr = "VOTING";
      } else if (state.status === T.ONGOING) {
        if (state.mode === T.NOLO) {
          statusStr = "NOLO";
        } else {
          if (state.mode === T.RAMI) {
            statusStr = "RAMI";
          }
        }
      }
      statusStr = `<span>${statusStr}</span>`;
      statusStr += "<span>tricks: " + state.tricks[0] + " - " + state.tricks[1] + "</span>";
      if (state.score != null) {
        if (state.score[0] > 0) {
          statusStr += "<span>score: " + escapeHtml(getTeamPlayers(0).join(" &amp; ")) + ": " + state.score[0] + "</span>";
        } else if (state.score[1] > 0) {
          statusStr += "<span>score: " + escapeHtml(getTeamPlayers(1).join(" &amp; ")) + ": " + state.score[1] + "</span>";
        } else {
          statusStr += "<span>score: 0</span>";
        }
      }
      $("#game_status").html(statusStr);
      // highlight the player in turn
      if (state.turn_id != null) {
        $(".player_data .player_name").removeClass("highlight_player");
        $("#player_" + state.turn_id + " .player_name").addClass("highlight_player");
      }
      return dbg();
    };
    cardClicked = function(event) {
      var card, cardId;
      // id is "card_X"
      cardId = $(this).find(".card").attr("id").slice(5);
      card = tupelo.hand[cardId];
      T.log(card);
      if (card != null) {
        request({
          url: "/game/play_card",
          success: function(result) {
            tupelo.my_turn = false;
            $("#hand .card").removeClass("card_selectable");
            // TODO: after playing a hand, this shows the next hand too quickly
            return getGameState();
          },
          error: function(xhr, astatus, error) {
            if (ajaxErr(xhr, astatus, error) !== true) {
              return window.alert(xhr.status + " " + error);
            }
          },
          data: {
            akey: tupelo.player.akey,
            game_id: tupelo.game_id,
            card: JSON.stringify(card)
          }
        });
      }
      return event.preventDefault();
    };
    updateHand = function(newHand) {
      var card, hand, html, i, item, j, len;
      html = "";
      hand = [];
      for (i = j = 0, len = newHand.length; j < len; i = ++j) {
        item = newHand[i];
        card = new T.Card(item.suit, item.value);
        hand.push(card);
        if (tupelo.my_turn) {
          html += "<a class=\"selectable\" href=\"#\">";
        }
        html += `<span class=\"card\" id=\"card_${i}\">` + card.toShortHtml() + "</span>";
        if (tupelo.my_turn) {
          html += "</a>";
        }
      }
      tupelo.hand = hand;
      $("#hand").html(html);
      if (tupelo.my_turn) {
        $("#hand .card").addClass("card_selectable");
        return $("#hand a").click(cardClicked);
      }
    };
    getGameState = function() {
      return request({
        url: "/game/get_state",
        success: function(result) {
          T.log(result);
          if (result.game_state != null) {
            updateGameState(result.game_state);
          }
          if (result.hand != null) {
            return updateHand(result.hand);
          }
        },
        data: {
          akey: tupelo.player.akey,
          game_id: tupelo.game_id
        }
      });
    };
    turnEvent = function(event) {
      T.log("turnEvent");
      tupelo.my_turn = true; // enables click callbacks for cards in hand
      getGameState();
      return true;
    };
    stateChanged = function(event) {
      T.log("stateChanged");
      if (event.game_state.status === T.VOTING) { // game started!
        startOk();
      } else if (event.game_state.status === T.ONGOING) { // VOTING -> ONGOING
        // allow the user to clear the table and proceed by clicking the table
        $("#game_area table tbody").click(clearTable);
        // setting timeout to show the voted cards for a longer time
        tupelo.clear_timeout = setTimeout(clearTable, 5000);
        return false;
      }
      return true;
    };
    processEvent = function() {
      var event, handled;
      handled = true;
      if (tupelo.events.length === 0) {
        T.log("no events to process");
        tupelo.event_timer = null;
        return;
      }
      event = tupelo.events.shift();
      if (event.game_state != null) {
        updateGameState(event.game_state);
      }
      switch (event.type) {
        case 1:
          handled = cardPlayed(event);
          break;
        case 2:
          handled = messageReceived(event);
          break;
        case 3:
          handled = trickPlayed(event);
          break;
        case 4:
          handled = turnEvent(event);
          break;
        case 5:
          handled = stateChanged(event);
          break;
        default:
          T.log("unknown event " + event.type);
      }
      if (handled === true) {
        return tupelo.event_timer = setTimeout(processEvent, 0);
      }
    };
    eventsOk = function(result) {
      var event, j, len;
      for (j = 0, len = result.length; j < len; j++) {
        event = result[j];
        /*
        if (result.length > 0)
          eventLog = $("#event_log")
          eventLog.append(JSON.stringify(result) + "\n")
          eventLog.scrollTop(eventLog[0].scrollHeight - eventLog.height())
        */
        // push events to queue
        tupelo.events.push(event);
      }
      if (tupelo.events.length > 0 && (tupelo.event_timer == null)) {
        tupelo.event_timer = setTimeout(processEvent, 0);
      }
      return dbg();
    };
    gameInfoOk = function(result) {
      var i, index, j, k, len, len1, myIndex, pl, ref, ref1;
      T.log("gameInfoOk");
      T.log(result);
      myIndex = 0;
      ref = result.players;
      // find my index
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        pl = ref[i];
        if (pl.id === tupelo.player.id) {
          myIndex = i;
          break;
        }
      }
      ref1 = result.players;
      for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
        pl = ref1[i];
        // place where the player goes when /me is always at the bottom
        index = (4 + i - myIndex) % 4;
        // set player id and name
        $("#table_" + index + " .player_data").attr("id", "player_" + pl.id);
        $("#player_" + pl.id + " .player_name").html(escapeHtml(pl.player_name));
      }
    };
    startOk = function(result) {
      if (tupelo.list_timer != null) {
        clearInterval(tupelo.list_timer);
        tupelo.list_timer = null;
      }
      $("#event_log").html("");
      setState("inGame");
      request({
        url: "/game/get_info",
        success: gameInfoOk,
        data: {
          game_id: tupelo.game_id,
          akey: tupelo.player.akey
        }
      });
      getGameState();
      return dbg();
    };
    updateLists = function() {
      request({
        url: "/game/list",
        success: listGamesOk,
        data: {
          akey: tupelo.player.akey
        }
      });
      return request({
        url: "/player/list",
        success: listPlayersOk,
        data: {
          akey: tupelo.player.akey
        }
      });
    };
    // bind DOM events
    $("#echo_ajax").click(function() {
      var text;
      text = $("#echo").val();
      return request({
        url: "/echo",
        data: {
          test: text
        },
        success: function(result) {
          $("#echo_result").html(escapeHtml(result));
          return $("#echo").val("");
        }
      });
    });
    $("#register_btn").click(function() {
      var input, name;
      input = $("#register_name");
      name = input.val();
      if (!name || input.hasClass("initial")) {
        alert("Please enter your name first");
        return;
      }
      tupelo.player = new T.Player(name);
      T.log(tupelo);
      return request({
        url: "/player/register",
        data: {
          player: JSON.stringify(tupelo.player)
        },
        success: registerOk
      });
    });
    // sign in by pressing enter
    $("#register_name").keyup(function(event) {
      if ((event.keyCode || event.which) === 13) {
        return $("#register_btn").click();
      }
    });
    $("#register_name").focus(function(event) {
      if ($(this).hasClass("initial")) {
        $(this).val("");
        return $(this).removeClass("initial");
      }
    });
    $("#quit_btn").click(function() {
      return request({
        url: "/player/quit",
        data: {
          akey: tupelo.player.akey
        },
        success: quitOk,
        error: function(xhr, astatus, error) {
          if (ajaxErr(xhr, astatus, error) === true) {
            return quitOk();
          }
        }
      });
    });
    $(".game_leave_btn").click(function() {
      // TODO: should we cancel timers already here?
      return request({
        url: "/game/leave",
        data: {
          akey: tupelo.player.akey,
          game_id: tupelo.game_id
        },
        success: leaveOk,
        error: function(xhr, astatus, error) {
          if (ajaxErr(xhr, astatus, error) === true) {
            return leaveOk();
          }
        }
      });
    });
    $("#game_create_btn").click(function() {
      // TODO: should we cancel timers already here?
      return request({
        url: "/game/create",
        data: {
          akey: tupelo.player.akey
        },
        success: gameCreateOk
      });
    });
    $("#game_start").click(function() {
      return request({
        url: "/game/start",
        data: {
          akey: tupelo.player.akey,
          game_id: tupelo.game_id
        },
        success: startOk
      });
    });
    $("#game_start_with_bots").click(function() {
      return request({
        url: "/game/start_with_bots",
        data: {
          akey: tupelo.player.akey,
          game_id: tupelo.game_id
        },
        success: startOk
      });
    });
    if (T.debug === true) {
      $("#debug").click(function() {
        return $(this).toggle();
      });
    } else {
      $("#debug").hide();
    }
    // leave the game when the user leaves the page
    $(window).unload(function() {
      if (tupelo.game_id != null) {
        return request({
          url: "/game/leave",
          async: false,
          data: {
            akey: tupelo.player.akey,
            game_id: tupelo.game_id
          }
        });
      }
    });
    // show a confirmation if the browser supports it
    window.onbeforeunload = function(e) {
      var msg;
      if (tupelo.game_id == null) {
        return undefined; // no dialog
      }
      e = e || window.event;
      msg = "By leaving the page you will also leave the game.";
      if (e) {
        e.returnValue = msg;
      }
      return msg;
    };
    // and finally, contact the server
    hello();
    return setState("initial");
  });

}).call(this);
